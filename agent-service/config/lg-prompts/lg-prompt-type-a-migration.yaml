# State Machine Configuration for Type-A App Migration Agent
# Goal:
# - Identify an application from the App Catalog (via app-migration-utility MCP).
# - Once uniquely identified (app_id/app_name/namespace/source_cluster/destination_cluster),
#   discover relevant OpenShift resources in that namespace (via OpenShift MCP).

settings:
  initial_state: "lookup_app"
  terminator_env_var: "AGENT_MESSAGE_TERMINATOR"
  agent_name: "type-a-app-migration"
  terminal_state: "end"
  empty_response_retry_count: 3

state_schema:
  business_fields:
    # Business logic fields (requested)
    app_id:
      type: "string"
      description: "Unique app identifier from app catalog"
      default: null
    app_name:
      type: "string"
      description: "App name from app catalog"
      default: null
    namespace:
      type: "string"
      description: "Namespace/project for the application"
      default: null
    source_cluster:
      type: "string"
      description: "Source cluster identifier/URL for the application"
      default: null
    destination_cluster:
      type: "string"
      description: "Destination cluster identifier/URL for the application"
      default: null

    # Supporting fields for this workflow
    app_lookup_results:
      type: "dict"
      description: "Raw response from search_app_catalog (and any formatted options shown to user)"
      default: null
    selected_app_choice:
      type: "string"
      description: "User selection when multiple app catalog matches exist"
      default: null
    namespace_discovery_output:
      type: "dict"
      description: "Raw discovery output from OpenShift MCP tools for the selected namespace"
      default: null

    _should_return_to_routing:
      type: "boolean"
      description: "Flag to indicate task completion and return to routing agent"
      default: false

states:
  lookup_app:
    type: "llm_processor"
    temperature: 0.2
    use_conversation_history: true
    allowed_tools: ["search_app_catalog"]
    prompt: |
      You are a helpful app migration assistant.

      CRITICAL: DO NOT announce what you are about to do. Execute tool calls silently and present only the results to the user.

      Your task: identify ONE unique application entry from the app catalog using the user's most recent message in the conversation.

      REQUIRED TOOL CALL:
      - You MUST call the tool named: search_app_catalog
      - Call: search_app_catalog(q=..., limit=50, offset=0)
      - Choose a good substring query (q) based on the user's most recent message (app_id, app name, namespace, source cluster, destination cluster).
      - CRITICAL: Do NOT write a fake tool call in text like [search_app_catalog(...)] — you must execute the actual tool call.

      After the tool returns results:
      - Build a UNIQUE set of tuples across:
        (app_id, app_name, namespace, source_cluster, destination_cluster)

      Determine uniqueness:
      - If the unique tuple set is empty: ask for a more specific query.
      - If it has exactly 1 tuple: proceed.
      - If it has more than 1 tuple: ask the user to select one.

      CRITICAL OUTPUT FORMAT (MUST MATCH EXACTLY):

      If 0 matches:
      STATUS: NONE
      MESSAGE: I couldn’t find any matching apps in the catalog. Please provide one of: app_id, app name, namespace, source cluster, or destination cluster.

      If exactly 1 match:
      STATUS: UNIQUE
      APP_ID: <app_id>
      APP_NAME: <app_name>
      NAMESPACE: <namespace>
      SOURCE_CLUSTER: <source_cluster>
      DESTINATION_CLUSTER: <destination_cluster>

      If multiple matches:
      STATUS: MULTIPLE
      OPTIONS:
      1) app_id=<...> | app_name=<...> | namespace=<...> | source_cluster=<...> | destination_cluster=<...>
      2) ...
      (show up to 15 options max, unique tuples only)
      MESSAGE: Reply with the option number (1-15) or the app_id to continue.
    transitions:
      success: "waiting_app_query" # overridden by response_analysis transitions below
    data_storage:
      app_lookup_results: "llm_response"
    response_analysis:
      conditions:
        - name: "unique"
          trigger_phrases: ["STATUS: UNIQUE"]
          actions:
            - type: "extract_data"
              pattern: "APP_ID:\\s*(.+)"
              field_name: "app_id"
              source: "response"
            - type: "extract_data"
              pattern: "APP_NAME:\\s*(.+)"
              field_name: "app_name"
              source: "response"
            - type: "extract_data"
              pattern: "NAMESPACE:\\s*(.+)"
              field_name: "namespace"
              source: "response"
            - type: "extract_data"
              pattern: "SOURCE_CLUSTER:\\s*(.+)"
              field_name: "source_cluster"
              source: "response"
            - type: "extract_data"
              pattern: "DESTINATION_CLUSTER:\\s*(.+)"
              field_name: "destination_cluster"
              source: "response"
            - type: "transition"
              target: "discover-app"
        - name: "multiple"
          trigger_phrases: ["STATUS: MULTIPLE"]
          actions:
            - type: "transition"
              target: "waiting_app_selection"
        - name: "none"
          trigger_phrases: ["STATUS: NONE"]
          actions:
            - type: "transition"
              target: "waiting_app_query"
      default_transition: "waiting_app_query"

  waiting_app_query:
    type: "waiting"
    transitions:
      user_input: "classify_app_query_intent"

  classify_app_query_intent:
    type: "intent_classifier"
    temperature: 0.2
    allowed_tools: [""]
    intent_prompt: |
      The user said: "{user_input}"

      Determine intent:
      - RETURN_TO_ROUTER: user wants to go back/stop/cancel
      - QUERY: user is providing a search term / app identifier / namespace / cluster reference to look up
      - UNCLEAR: user input doesn't contain a usable query

      Respond with only: RETURN_TO_ROUTER, QUERY, or UNCLEAR
    intent_actions:
      RETURN_TO_ROUTER:
        response: "task_complete_return_to_router"
        data_storage:
          _should_return_to_routing: true
        next_state: "end"
      QUERY:
        next_state: "lookup_app"
      UNCLEAR:
        response: "Please provide a search term (app_id, app name, namespace, source cluster, or destination cluster). Or say 'cancel' to return to the router."
        next_state: "waiting_app_query"

  waiting_app_selection:
    type: "waiting"
    transitions:
      user_input: "classify_app_selection"

  classify_app_selection:
    type: "intent_classifier"
    temperature: 0.2
    allowed_tools: [""]
    intent_prompt: |
      The user said: "{user_input}"

      The last app lookup response (with options) was:
      {app_lookup_results.response}

      Determine intent:
      - RETURN_TO_ROUTER: user wants to go back/stop/cancel
      - RETRY_LOOKUP: user wants to search again with a new query
      - VALID_SELECTION: user selected an option number (1-15) or an app_id from the options
      - INVALID_SELECTION: selection doesn't match any option

      Respond with only: RETURN_TO_ROUTER, RETRY_LOOKUP, VALID_SELECTION, or INVALID_SELECTION
    intent_actions:
      RETURN_TO_ROUTER:
        response: "task_complete_return_to_router"
        data_storage:
          _should_return_to_routing: true
        next_state: "end"
      RETRY_LOOKUP:
        response: "Sure — please provide a new search term (app_id, app name, namespace, source cluster, or destination cluster)."
        next_state: "waiting_app_query"
      VALID_SELECTION:
        next_state: "resolve_app_selection"
        data_storage:
          selected_app_choice: "{user_input}"
      INVALID_SELECTION:
        response: "I don’t see that selection in the options. Please reply with an option number (1-15) or an app_id from the list."
        next_state: "waiting_app_selection"

  resolve_app_selection:
    type: "llm_processor"
    temperature: 0.2
    allowed_tools: [""]
    prompt: |
      The user selected: "{selected_app_choice}"

      Use ONLY the following options (do not invent anything):
      {app_lookup_results.response}

      If you can resolve the user's choice to exactly one option, output:
      STATUS: UNIQUE
      APP_ID: <app_id>
      APP_NAME: <app_name>
      NAMESPACE: <namespace>
      SOURCE_CLUSTER: <source_cluster>
      DESTINATION_CLUSTER: <destination_cluster>

      If you cannot resolve uniquely, output:
      STATUS: ERROR
      MESSAGE: Please select one option number (1-15) or paste the exact app_id from the options list.
    transitions:
      success: "waiting_app_selection" # overridden by response_analysis transitions below
    response_analysis:
      conditions:
        - name: "unique"
          trigger_phrases: ["STATUS: UNIQUE"]
          actions:
            - type: "extract_data"
              pattern: "APP_ID:\\s*(.+)"
              field_name: "app_id"
              source: "response"
            - type: "extract_data"
              pattern: "APP_NAME:\\s*(.+)"
              field_name: "app_name"
              source: "response"
            - type: "extract_data"
              pattern: "NAMESPACE:\\s*(.+)"
              field_name: "namespace"
              source: "response"
            - type: "extract_data"
              pattern: "SOURCE_CLUSTER:\\s*(.+)"
              field_name: "source_cluster"
              source: "response"
            - type: "extract_data"
              pattern: "DESTINATION_CLUSTER:\\s*(.+)"
              field_name: "destination_cluster"
              source: "response"
            - type: "transition"
              target: "discover-app"
        - name: "error"
          trigger_phrases: ["STATUS: ERROR"]
          actions:
            - type: "transition"
              target: "waiting_app_selection"
      default_transition: "waiting_app_selection"

  discover-app:
    type: "llm_processor"
    temperature: 0.2
    allowed_tools:
      - "oc_get_deployments"
      - "oc_get_statefulsets"
      - "oc_get_daemonsets"
      - "oc_get_services"
      - "oc_get_routes"
      - "oc_get_ingresses"
      - "oc_get_pvcs"
      - "oc_get_virtualmachines"
      - "oc_get_virtualmachineinstances"
    prompt: |
      You have identified the application:
      - app_id: {app_id}
      - app_name: {app_name}
      - namespace: {namespace}
      - source_cluster: {source_cluster}
      - destination_cluster: {destination_cluster}

      CRITICAL: DO NOT announce what you are about to do. Execute tool calls silently and present only the results to the user.

      Your task: discover the resources in the selected namespace using OpenShift MCP tools.

      RULES:
      - Do NOT read or output Secret data. Do NOT fetch secret values. If you must reference secrets, only mention names and namespaces.
      - Keep output bounded: if there are many resources, show the top ~50 total items and clearly state it is a partial view.

      REQUIRED TOOL FLOW (use the namespace {namespace}):
      - List Deployments, StatefulSets, DaemonSets
      - List Services and Routes/Ingresses (show hostnames if present)
      - List PVCs
      - If present, list OpenShift Virtualization resources: VirtualMachines and VirtualMachineInstances

      Output a single response with:
      - App Context (the 5 fields above)
      - Namespace Resource Summary (grouped by kind, with names)
      - Exposures (route/ingress hostnames if any)

      End by asking:
      "Do you want to look up another app, re-run discovery, or return to the main router? (another / rediscover / router)"
    transitions:
      success: "waiting_post_discovery"
    data_storage:
      namespace_discovery_output: "llm_response"

  waiting_post_discovery:
    type: "waiting"
    transitions:
      user_input: "post_discovery_intent"

  post_discovery_intent:
    type: "intent_classifier"
    temperature: 0.2
    allowed_tools: [""]
    intent_prompt: |
      The user said: "{user_input}"

      They were asked: another / rediscover / router.

      Classify intent:
      - RETURN_TO_ROUTER
      - ANOTHER_APP
      - REDISCOVER
      - UNCLEAR

      Respond with only: RETURN_TO_ROUTER, ANOTHER_APP, REDISCOVER, or UNCLEAR
    intent_actions:
      RETURN_TO_ROUTER:
        response: "task_complete_return_to_router"
        data_storage:
          _should_return_to_routing: true
        next_state: "end"
      ANOTHER_APP:
        response: "Okay — what app should I look up? You can provide app_id, app name, namespace, source cluster, or destination cluster."
        data_storage:
          app_id: null
          app_name: null
          namespace: null
          source_cluster: null
          destination_cluster: null
          selected_app_choice: null
          app_lookup_results: null
          namespace_discovery_output: null
        next_state: "waiting_app_query"
      REDISCOVER:
        next_state: "discover-app"
      UNCLEAR:
        response: "Please reply with one of: another / rediscover / router"
        next_state: "waiting_post_discovery"

  end:
    type: "terminal"
    reset_behavior:
      reset_state: "lookup_app"
      clear_data:
        - "messages"
        - "current_state"
        - "app_id"
        - "app_name"
        - "namespace"
        - "source_cluster"
        - "destination_cluster"
        - "app_lookup_results"
        - "selected_app_choice"
        - "namespace_discovery_output"
        # NOTE: _should_return_to_routing is NOT cleared here; it must persist until session manager detects it.
